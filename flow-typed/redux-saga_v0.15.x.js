// flow-typed signature: 4e8e68780a5554bd449a725c65dc80aa
// flow-typed version: <<STUB>>/redux-saga_v0.15.6/flow_v0.57.3

/**
 * @author Matt Kane (@ascorbic)
 * Mosty autogenerated with flow-gen
 */

declare module 'redux-saga' {

/**
 * Annotate return type of generators with `SagaIterator` to get strict
 * type-checking of yielded effects.
 */
declare export type SagaIterator = IterableIterator<Effect | Effect[]>;
declare type Saga0 = () => Iterator<any>;
declare type Saga1<T1>= (arg1: T1) => Iterator<any>;
declare type Saga2<T1, T2>= (arg1: T1, arg2: T2) => Iterator<any>;
declare type Saga3<T1, T2, T3>= (arg1: T1, arg2: T2, arg3: T3) => Iterator<any>;
declare type Saga4<T1, T2, T3, T4>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Iterator<any>;
declare type Saga5<T1, T2, T3, T4, T5>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Iterator<any>;
declare type Saga6Rest<T1, T2, T3, T4, T5, T6>= (
    arg1: T1,
    arg2: T2,
    arg3: T3,
    arg4: T4,
    arg5: T5,
    arg6: T6,
    ...rest: any[]) => Iterator<any>;
declare export interface Monitor {
    effectTriggered(
            desc: {
                effectId: number,
                parentEffectId: number,
                label?: string,
                root?: boolean,
                effect: Effect
            }): void,
        effectResolved(effectId: number, res: any): void,
        effectRejected(effectId: number, err: any): void,
        effectCancelled(effectId: number): void,
        actionDispatched<A>(action: A): void
}
declare export type SagaMiddleware<C>= {
    run(saga: Saga0): Task,
    run<T1>(saga: Saga1<T1>, arg1: T1): Task,
    run<T1,
    T2>(saga: Saga2<T1, T2>, arg1: T1, arg2: T2): Task,
    run<T1,
    T2,
    T3>(saga: Saga3<T1, T2, T3>, arg1: T1, arg2: T2, arg3: T3): Task,
    run<T1,
    T2,
    T3,
    T4>(
        saga: Saga4<T1, T2, T3, T4>,
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4): Task,
    run<T1,
    T2,
    T3,
    T4,
    T5>(
        saga: Saga5<T1, T2, T3, T4, T5>,
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4,
        arg5: T5): Task,
    run<T1,
    T2,
    T3,
    T4,
    T5,
    T6>(
        saga: Saga6Rest<T1, T2, T3, T4, T5, T6>,
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4,
        arg5: T5,
        arg6: T6,
        ...rest: any[]): Task,
    setContext(props: Partial<C>): void
} & Middleware
declare export type Logger = (level: string, ...args: any[]) => void;
declare export type Emit<T>= (input: T) => void;
declare export interface SagaMiddlewareOptions<C>{
    context?: C,
    sagaMonitor?: Monitor,
    logger?: Logger,
    onError(error: Error): void,
    emitter(emit: Emit<Action>): Emit<any >
}
declare export default function sagaMiddlewareFactory<C>(options?: SagaMiddlewareOptions<C>): SagaMiddleware<C>declare type Unsubscribe = () => void;
declare type Subscribe<T>= (cb: (input: T | END) => void) => Unsubscribe;
declare export interface RunSagaOptions<A, S>{
    context?: object,
    subscribe?: Subscribe<A>,
    dispatch(input: A): any,
    getState(): S,
    sagaMonitor?: Monitor,
    logger?: Logger,
    onError(error: Error): void
}
declare export function runSaga<A, S>(storeInterface: RunSagaOptions<A, S>, saga: Saga0): Taskdeclare export var CANCEL: string;
declare export type END = {
    type: @ @redux - saga / CHANNEL_END
};
declare export var END: END;
declare export type Predicate<T>= (arg: T) => boolean;
declare export interface Task {
    isRunning(): boolean,
        isCancelled(): boolean,
        result(): any | void,
        result<T>(): T | void,
        error(): any | void,
        done: Promise<any>,
        cancel(): void,
        setContext<C>(props: Partial<C>): void
}
declare export interface Buffer<T>{
    isEmpty(): boolean,
    put(message: T): void,
    take(): T | void,
    flush(): void
}
declare export interface Channel<T>{
    take(cb: (message: T | END) => void): void,
    put(message: T | END): void,
    flush(): void,
    close(): void
}
declare export function channel<T>(buffer?: Buffer<T>): Channel<T>declare export function eventChannel<T>(
    subscribe: Subscribe<T>,
    buffer?: Buffer<T>,
    matcher?: Predicate<T>): Channel<T>declare export var buffers: {
    none<T>(): Buffer<T>,
    fixed<T>(limit?: number): Buffer<T>,
    dropping<T>(limit?: number): Buffer<T>,
    sliding<T>(limit?: number): Buffer<T>,
    expanding<T>(limit?: number): Buffer<T >
};
declare export function delay(ms: number): Promise<> declare type HelperFunc0<A>= (action: A) => any;
declare type HelperFunc1<A, T1>= (arg1: T1, action: A) => any;
declare type HelperFunc2<A, T1, T2>= (arg1: T1, arg2: T2, action: A) => any;
declare type HelperFunc3<A, T1, T2, T3>= (arg1: T1, arg2: T2, arg3: T3, action: A) => any;
declare type HelperFunc4<A, T1, T2, T3, T4>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4, action: A) => any;
declare type HelperFunc5<A, T1, T2, T3, T4, T5>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, action: A) => any;
declare type HelperFunc6Rest<A, T1, T2, T3, T4, T5, T6>= (
    arg1: T1,
    arg2: T2,
    arg3: T3,
    arg4: T4,
    arg5: T5,
    arg6: T6,
    arg7: any,
    ...rest: any[]) => any;
/**
 * 
 * @deprecated  
 */
declare export function takeEvery<A>(pattern: Pattern, worker: HelperFunc0<A>): SagaIteratordeclare export var takeLatest: typeof takeEvery;
/**
 * 
 * @deprecated  
 */
declare export function throttle<A>(ms: number, pattern: Pattern, worker: HelperFunc0<A>): SagaIterator}

declare module 'redux-saga/effects' {

declare type ActionType = string | number | ;
declare type StringableActionCreator<A>= {
    (...args: any[]): A,
    toString(): string
};
declare type SubPattern = ActionType | Predicate<Action>| StringableActionCreator<Action>;
declare export type Pattern = SubPattern | SubPattern[];
declare export interface TakeEffectDescriptor {
    pattern: Pattern,
        maybe?: boolean
}
declare export interface ChannelTakeEffectDescriptor<T>{
    channel: Channel<T>,
    maybe?: boolean
}
declare export interface TakeEffect {
    TAKE: TakeEffectDescriptor
}
declare export interface ChannelTakeEffect<T>{
    TAKE: ChannelTakeEffectDescriptor<T >
}
declare export interface Take {
    (pattern?: Pattern): TakeEffect,
    (channel: Channel<T>): ChannelTakeEffect<T>,
        maybe<A>(pattern?: Pattern): TakeEffect,
        maybe<T>(channel: Channel<T>): ChannelTakeEffect<T >
}
declare export var take: Take;
declare export var takem: typeof undefined;
declare export interface PutEffectDescriptor<A>{
    action: A,
    channel: null,
    resolve?: boolean
}
declare export interface ChannelPutEffectDescriptor<T>{
    action: T,
    channel: Channel<T>,
    resolve?: boolean
}
declare export interface PutEffect<A>{
    PUT: PutEffectDescriptor<A >
}
declare export interface ChannelPutEffect<T>{
    PUT: ChannelPutEffectDescriptor<T >
}
declare export interface Put {
    (action: A): PutEffect<A>,
        (channel: Channel<T>, action: T | END): ChannelPutEffect<T | END>,
        resolve<A>(action: A): PutEffect<A>,
        resolve<T>(channel: Channel<T>, action: T | END): ChannelPutEffect<T | END>,

        /**
         * 
         * @deprecated  
         */
        sync<A>(action: A): PutEffect<A>,

        /**
         * 
         * @deprecated  
         */
        sync<T>(channel: Channel<T>, action: T | END): ChannelPutEffect<T | END >
}
declare export var put: Put;
declare export type GenericAllEffectDescriptor<T>= T[] | {
    [key: string]: T
};
declare export interface GenericAllEffect<T>{
    ALL: GenericAllEffectDescriptor<T >
}
declare export type AllEffectDescriptor = GenericAllEffectDescriptor<Effect>;
declare export interface AllEffect {
    ALL: AllEffectDescriptor
}
declare export function all(effects: Effect[]): AllEffectdeclare export type GenericRaceEffectDescriptor<T>= {
    [key: string]: T
};
declare export interface GenericRaceEffect<T>{
    RACE: GenericRaceEffectDescriptor<T >
}
declare export type RaceEffectDescriptor = GenericRaceEffectDescriptor<Effect>;
declare export interface RaceEffect {
    RACE: RaceEffectDescriptor
}
declare export function race(effects: {
    [key: string]: Effect
}): RaceEffectdeclare export interface CallEffectDescriptor {
    context: any,
        fn: Function,
        args: any[]
}
declare export interface CallEffect {
    CALL: CallEffectDescriptor
}
declare type Func0 = () => any;
declare type Func1<T1>= (arg1: T1) => any;
declare type Func2<T1, T2>= (arg1: T1, arg2: T2) => any;
declare type Func3<T1, T2, T3>= (arg1: T1, arg2: T2, arg3: T3) => any;
declare type Func4<T1, T2, T3, T4>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => any;
declare type Func5<T1, T2, T3, T4, T5>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => any;
declare type Func6Rest<T1, T2, T3, T4, T5, T6>= (
    arg1: T1,
    arg2: T2,
    arg3: T3,
    arg4: T4,
    arg5: T5,
    arg6: T6,
    ...rest: any[]) => any;
declare export type CallEffectFn<F>= F | [any, F] | {
    context: any,
    fn: F
};
declare export type CallEffectNamedFn<C, Name>= [C, Name] | {
    context: C,
    fn: Name
};
declare interface CallEffectFactory<R>{
    (fn: CallEffectFn<Func0>): R,
    (fn: CallEffectFn<Func1<T1 >> , arg1: T1): R,
    (fn: CallEffectFn<Func2<T1, T2 >> , arg1: T1, arg2: T2): R,
    (fn: CallEffectFn<Func3<T1, T2, T3 >> , arg1: T1, arg2: T2, arg3: T3): R,
    (fn: CallEffectFn<Func4<T1, T2, T3, T4 >> , arg1: T1, arg2: T2, arg3: T3, arg4: T4): R,
    (fn: CallEffectFn<Func5<T1, T2, T3, T4, T5 >> , arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): R,
    (fn: CallEffectFn<Func6Rest<T1, T2, T3, T4, T5, T6 >> , arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, ...rest: any[]): R,
    (fn: CallEffectNamedFn<C, N>): R,
    (fn: CallEffectNamedFn<C, N>, arg1: T1): R,
    (fn: CallEffectNamedFn<C, N>, arg1: T1, arg2: T2): R,
    (fn: CallEffectNamedFn<C, N>, arg1: T1, arg2: T2, arg3: T3): R,
    (fn: CallEffectNamedFn<C, N>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): R,
    (fn: CallEffectNamedFn<C, N>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): R,
    (fn: CallEffectNamedFn<C, N>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6, ...rest: any[]): R
}
declare export var call: CallEffectFactory<CallEffect>;
declare export function apply(context: any, fn: Func0): CallEffectdeclare export interface CpsEffect {
    CPS: CallEffectDescriptor
}
declare type CpsCallback = {
    (error: any, result: any): void,
    cancel(): void
};
declare export function cps(fn: CallEffectFn<Func1<CpsCallback >> ): CpsEffectdeclare export type ForkEffectDescriptor = {
    detached?: boolean
} & CallEffectDescriptor
declare export interface ForkEffect {
    FORK: ForkEffectDescriptor
}
declare export var fork: CallEffectFactory<ForkEffect>;
declare export var spawn: CallEffectFactory<ForkEffect>;
declare export type JoinEffectDescriptor = Task;
declare export interface JoinEffect {
    JOIN: JoinEffectDescriptor
}
declare export function join(task: Task): JoinEffectdeclare type SELF_CANCELLATION = @ @redux - saga / SELF_CANCELLATION;
declare export type CancelEffectDescriptor = Task | SELF_CANCELLATION;
declare export interface CancelEffect {
    CANCEL: CancelEffectDescriptor
}
declare export function cancel(): CancelEffectdeclare export interface SelectEffectDescriptor {
    selector(state: any, ...args: any[]): any,
        args: any[]
}
declare export interface SelectEffect {
    SELECT: SelectEffectDescriptor
}
declare export function select(): SelectEffectdeclare export interface ActionChannelEffectDescriptor {
    pattern: Pattern,
        buffer?: Buffer<Action >
}
declare export interface ActionChannelEffect {
    ACTION_CHANNEL: ActionChannelEffectDescriptor
}
declare export function actionChannel(pattern: Pattern, buffer?: Buffer<Action>): ActionChannelEffectdeclare export type CancelledEffectDescriptor = {};
declare export interface CancelledEffect {
    CANCELLED: CancelledEffectDescriptor
}
declare export function cancelled(): CancelledEffectdeclare export type FlushEffectDescriptor<T>= Channel<T>;
declare export interface FlushEffect<T>{
    FLUSH: FlushEffectDescriptor<T >
}
declare export function flush<T>(channel: Channel<T>): FlushEffect<T>declare export type GetContextEffectDescriptor = string;
declare export interface GetContextEffect {
    GET_CONTEXT: GetContextEffectDescriptor
}
declare export function getContext(prop: string): GetContextEffectdeclare export type SetContextEffectDescriptor<C>= C;
declare export interface SetContextEffect<C>{
    SET_CONTEXT: SetContextEffectDescriptor<C >
}
declare export function setContext<C>(props: C): SetContextEffect<C>declare export interface RootEffect {
    root: undefined,
        saga(...args: any[]): Iterator<any>,
        args: any[]
}
declare export type Effect = RootEffect |
    TakeEffect |
    ChannelTakeEffect<any >
    |
    PutEffect<any >
    |
    ChannelPutEffect<any >
    |
    AllEffect |
    RaceEffect |
    CallEffect |
    CpsEffect |
    ForkEffect |
    JoinEffect |
    CancelEffect |
    SelectEffect |
    ActionChannelEffect |
    CancelledEffect |
    FlushEffect<any >
    |
    GetContextEffect |
    SetContextEffect<any>;
declare type HelperFunc0<A>= (action: A) => any;
declare type HelperFunc1<A, T1>= (arg1: T1, action: A) => any;
declare type HelperFunc2<A, T1, T2>= (arg1: T1, arg2: T2, action: A) => any;
declare type HelperFunc3<A, T1, T2, T3>= (arg1: T1, arg2: T2, arg3: T3, action: A) => any;
declare type HelperFunc4<A, T1, T2, T3, T4>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4, action: A) => any;
declare type HelperFunc5<A, T1, T2, T3, T4, T5>= (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, action: A) => any;
declare type HelperFunc6Rest<A, T1, T2, T3, T4, T5, T6>= (
    arg1: T1,
    arg2: T2,
    arg3: T3,
    arg4: T4,
    arg5: T5,
    arg6: T6,
    arg7: any,
    ...rest: any[]) => any;
declare export function takeEvery<A>(pattern: Pattern, worker: HelperFunc0<A>): ForkEffectdeclare export var takeLatest: typeof takeEvery;
declare export function throttle<A>(ms: number, pattern: Pattern, worker: HelperFunc0<A>): ForkEffect
}


declare module 'redux-saga/utils' {
  
/**
 * Flowtype definitions for utils
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare export var TASK: string;
declare export var SAGA_ACTION: ;
declare export function noop(): voiddeclare export type GuardPredicate<T>= (arg: any) => T;
declare export var is: {
    undef: GuardPredicate<void>,
    notUndef: GuardPredicate<any>,
    func: GuardPredicate<Function>,
    number: GuardPredicate<number>,
    string: GuardPredicate<string>,
    array: GuardPredicate<Array<any >> ,
    object: GuardPredicate<object>,
    promise: GuardPredicate<Promise<any >> ,
    iterator: GuardPredicate<Iterator<any >> ,
    iterable: GuardPredicate<Iterable<any >> ,
    task: GuardPredicate<Task>,
    observable: GuardPredicate<{
        subscribe: Function
    }>,
    buffer: GuardPredicate<Buffer<any >> ,
    pattern: GuardPredicate<Pattern>,
    channel: GuardPredicate<Channel<any >> ,
    helper: GuardPredicate<SagaIterator>,
    stringableFunc: GuardPredicate<Function >
};
declare interface Deferred<R>{
    resolve(result: R): void,
    reject(error: any): void,
    promise: Promise<R >
}
declare export function deferred<T, R>(props?: T): T & Deferred<R>declare export function arrayOfDeffered<T>(length: number): Deferred<T>[] declare type MockTask = {
    setRunning(running: boolean): void,
    setResult(result: any): void,
    setError(error: any): void
} & Task
declare export function createMockTask(): MockTaskdeclare export var asEffect: {
    take(effect: Effect): void | TakeEffectDescriptor | ChannelTakeEffectDescriptor<any>,
    put(
        effect: Effect): void | PutEffectDescriptor<any>| ChannelPutEffectDescriptor<any>,
    all(effect: Effect): void | AllEffectDescriptor,
    race(effect: Effect): void | RaceEffectDescriptor,
    call(effect: Effect): void | CallEffectDescriptor,
    cps(effect: Effect): void | CallEffectDescriptor,
    fork(effect: Effect): void | ForkEffectDescriptor,
    join(effect: Effect): void | JoinEffectDescriptor,
    cancel(effect: Effect): void | CancelEffectDescriptor,
    select(effect: Effect): void | SelectEffectDescriptor,
    actionChannel(effect: Effect): void | ActionChannelEffectDescriptor,
    cancelled(effect: Effect): void | CancelledEffectDescriptor,
    flush(effect: Effect): void | FlushEffectDescriptor<any>,
    getContext(effect: Effect): void | GetContextEffectDescriptor,
    setContext(effect: Effect): void | SetContextEffectDescriptor<any >
};
declare type SagaIteratorClone = {
    clone: () => SagaIteratorClone
} & SagaIterator
declare export function cloneableGenerator(iterator: () => SagaIterator): () => SagaIteratorClone
}